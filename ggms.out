CSE 423 HW4 test run output for schwierzalexander_9378_1243648_GriegoGroverMendozaSchwierz_hw4
------------------------------------------------------------
	.zip Compiles w/no warnings:           _2/2
	Exe named puny Runs on Basic Stuff:    _1/2 bogus semantic error
	Valgrind reports no warnings:          _1/2 uninitialized var
	-symtab prints symbol tables:          _0/6 bogus semantic error
	Undeclared Error:                      _4/4
	Redeclaration Error:                   _0/4
	-------------------------------------------
	Total:                                 _8/20

	-------------------------------------------------------

cp "schwierzalexander_9378_1243648_GriegoGroverMendozaSchwierz_hw4.zip" schwierzalexander_9378_1243648_GriegoGroverMendozaSchwierz_hw4/HW4.zip
chdir: schwierzalexander_9378_1243648_GriegoGroverMendozaSchwierz_hw4
	(untarring)
	(extracting done rv=0)
	(make)

bison --debug punygram.y -v
punygram.y: warning: 2 shift/reduce conflicts [-Wconflicts-sr]
punygram.y: note: rerun with option '-Wcounterexamples' to generate conflict counterexamples
bison -d --debug punygram.y
punygram.y: warning: 2 shift/reduce conflicts [-Wconflicts-sr]
punygram.y: note: rerun with option '-Wcounterexamples' to generate conflict counterexamples
flex punylex.l
gcc -g -Wall -c punygram.tab.c lex.yy.c utils.c main.c back.c tree.c symtab.c printsyms.c
gcc -g -Wall lex.yy.o punygram.tab.o utils.o tree.o main.o back.o symtab.o -o puny
#./puny test.py


	(make done rv=0)

------------------------------------------------------------------------

Executing from: /fserv/home/jeffery/submit/423/hw4/schwierzalexander_9378_1243648_GriegoGroverMendozaSchwierz_hw4
	Test#1 Input:
x : int
x = 5
x = x * x

	Test command: timeout 1s ./puny  ../basic.py | head -40

	Test Output [expect no errors]
Name 'x' not defined
File: ../basic.py
	(testrun done rv=0)
==438929== Memcheck, a memory error detector
==438929== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==438929== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
==438929== Command: ./puny ../basic.py
==438929== 
==438929== Conditional jump or move depends on uninitialised value(s)
==438929==    at 0x1159DA: locate_undeclared (symtab.c:58)
==438929==    by 0x115967: semantics (symtab.c:43)
==438929==    by 0x115281: main (main.c:77)
==438929== 
==438929== Conditional jump or move depends on uninitialised value(s)
==438929==    at 0x1159DA: locate_undeclared (symtab.c:58)
==438929==    by 0x115A25: locate_undeclared (symtab.c:61)
==438929==    by 0x115967: semantics (symtab.c:43)
==438929==    by 0x115281: main (main.c:77)
==438929== 
==438929== Conditional jump or move depends on uninitialised value(s)
==438929==    at 0x1159DA: locate_undeclared (symtab.c:58)
==438929==    by 0x115A25: locate_undeclared (symtab.c:61)
==438929==    by 0x115A25: locate_undeclared (symtab.c:61)
==438929==    by 0x115967: semantics (symtab.c:43)
==438929==    by 0x115281: main (main.c:77)
==438929== 
==438929== Conditional jump or move depends on uninitialised value(s)
==438929==    at 0x1159DA: locate_undeclared (symtab.c:58)
==438929==    by 0x115A25: locate_undeclared (symtab.c:61)
==438929==    by 0x115A25: locate_undeclared (symtab.c:61)
==438929==    by 0x115A25: locate_undeclared (symtab.c:61)
==438929==    by 0x115967: semantics (symtab.c:43)
==438929==    by 0x115281: main (main.c:77)
==438929== 
Name 'x' not defined
File: ../basic.py
==438929== 
==438929== HEAP SUMMARY:
==438929==     in use at exit: 69,122 bytes in 380 blocks
==438929==   total heap usage: 383 allocs, 3 frees, 85,508 bytes allocated
==438929== 
==438929== LEAK SUMMARY:
==438929==    definitely lost: 448 bytes in 4 blocks
==438929==    indirectly lost: 309 bytes in 16 blocks
==438929==      possibly lost: 0 bytes in 0 blocks
==438929==    still reachable: 68,365 bytes in 360 blocks
==438929==         suppressed: 0 bytes in 0 blocks
==438929== Rerun with --leak-check=full to see details of leaked memory
==438929== 
==438929== Use --track-origins=yes to see where uninitialised values come from
==438929== For lists of detected and suppressed errors, rerun with: -s
==438929== ERROR SUMMARY: 7 errors from 4 contexts (suppressed: 0 from 0)
exit status: 3 expected 0

------------------------------------------------------------------------

Executing from: /fserv/home/jeffery/submit/423/hw4/schwierzalexander_9378_1243648_GriegoGroverMendozaSchwierz_hw4
	Test#2 Input:
a : list
a = list(range(8))
a[5] = 5
print(a[5])

	Test command: timeout 1s ./puny -symtab ../list.py | head -40

	Test Output [expect symbol table(s)]
Name 'a' not defined
File: ../list.py
	(testrun done rv=0)

------------------------------------------------------------------------

Executing from: /fserv/home/jeffery/submit/423/hw4/schwierzalexander_9378_1243648_GriegoGroverMendozaSchwierz_hw4
	Test#3 Input:
print(a)

	Test command: timeout 1s ./puny  ../undeclared.py | head -40

	Test Output [expect an undeclared variable on line 1]
Name 'a' not defined
File: ../undeclared.py
	(testrun done rv=0)

------------------------------------------------------------------------

Executing from: /fserv/home/jeffery/submit/423/hw4/schwierzalexander_9378_1243648_GriegoGroverMendozaSchwierz_hw4
	Test#4 Input:
n1 : int
n2 : int

def f(n1 : float):
   n2 : float
   y : int

   n1 : float # same as name of parameter
   print(n1)

	Test command: timeout 1s ./puny  ../redeclared.py | head -40

	Test Output [expect a redeclaration error on line 8]
Name 'n1' not defined
File: ../redeclared.py
	(testrun done rv=0)
------------------------------------------------------------
Source Code:
------------------------------------------------------------
files: "errdef.h symtab.h tree.h utils.h back.c main.c printsyms.c symtab.c tree.c utils.c " "punylex.l" "punygram.y"
------------------------------------------------------------

enum {
    LEX_ERR = 1,
    SYN_ERR,
    SEM_ERR
};
#define HASH_TABLE_SIZE (1 << 12)
struct tree; // Definition found in tree.h
typedef unsigned int uint;

typedef struct sym_table {
    int nBuckets;               /* # of buckets */
    int nEntries;               /* # of symbols in the table */
    int level;                  /* Nesting level */
    char *scope;                /* Scope name */
    struct sym_table *parent;   /* enclosing scope, superclass etc. */
    struct sym_entry **tbl;
    struct sym_entry *references; /* referenced but not declared variables */
    /* more per-scope/per-symbol-table attributes go here */
} *SymbolTable;

typedef struct sym_entry {
    SymbolTable table;          /* what symbol table do we belong to */
    char *ident;                /* identifier name */
    int lineno;                 /* One what line was this first found? */
    int declared;               /* is this symbol declared in this scope? */
    struct sym_table *nested;   /* nested symbol table (if any) */
    /* more symbol attributes go here for code generation */
    struct sym_entry *next;
} *SymbolTableEntry;

// Data structure for symbol table stack
typedef struct symtab_stack {
    int top;
    struct sym_table **tstack;
} *SymtabStack;

// Prototypes
void add_global_names(SymbolTable st, struct tree *t);
void add_puny_builtins(SymbolTable st);
void check_redeclared_variables(SymbolTable st);
void check_undeclared_variables(SymbolTable st);
void check_decls(struct tree *t, SymbolTable st);
void free_symtab(SymbolTable st);
void get_assignment_symbols(struct tree *t, SymbolTable st);
void get_function_params(struct tree *t, SymbolTable ftable);
SymbolTable get_global_symtab(SymbolTable st);
uint hash(SymbolTable st, char *s);
SymbolTableEntry findsymbol(SymbolTable st, char *s);
void insertclass(struct tree *t, SymbolTable st);
void insertfunction(struct tree *t, SymbolTable st);
int insertsymbol(SymbolTable st, char *s, int lineno); // TODO: Add typeptr later
void locate_undeclared(struct tree *t, SymbolTable st);
void mark_undeclared(SymbolTable st);
SymbolTable mksymtab(int nbuckets, char *table_name);
SymbolTable mknested(int nbuckets, SymbolTable parent, char *scope);
void populate_symboltables(struct tree *t, SymbolTable st);
void printsymbols(SymbolTable st, int level);
SymbolTableEntry removesymbol(SymbolTable st, char *s);
void semantics(struct tree *t, SymbolTable st);
void scope_enter(char *s);
void scope_exit();
void scope_level();
void scope_lookup(char *name);
void scope_lookup_current(char *name);
#define TEXT_TRUNCATION_LEVEL 20
struct sym_table;

typedef struct token {
    int category;   /* the integer code returned by yylex */
    char *text;     /* the actual string (lexeme) matched */
    int lineno;     /* the line number on which the token occurs */
    int column;     /* the column */
    char *filename; /* the source file in which the token occurs */
    int ival;       /* for integer constants, store binary value here */
    double dval;	   /* for real constants, store binary value here */
    char *sval;     /* for string constants, malloc space, de-escape, store */
                    /*    the string (less quotes and after escapes) here */
} token_t;


typedef struct tokenlist {
    token_t *t;
    struct tokenlist *next;
} tokenlist_t;

typedef struct tree {
    int prodrule;
    char *symbolname;
    int nkids;
    struct sym_table *stab;
    struct token *leaf;
    struct tree *kids[9];
} tree_t;

// Token/List/Tree function prototypes
int alctoken(int category);
void create_token(tokenlist_t *list, int category, char *yytext, int rows, int column, char *filename);
int insert_node(tokenlist_t *l, double dval, char *sval, int ival, char *text, int cat, int rows, int column, char *filename);
void print_list(tokenlist_t *l);
void dealloc_list(tokenlist_t *l);
void free_tree(struct tree *);
void free_token(token_t *t);
int print_token(token_t *node);
void printsyms(struct tree *t);
void printsymbol(char *s);
tokenlist_t *insert_tail_node(tokenlist_t *l, tokenlist_t *node);
int get_lineno(char *text, int rows);
int get_column(char *text, int column);
struct tree* append_kid(struct tree * kidspassed[], char * symbnam);
void print_tree(struct tree * t, int depth);
struct tree* make_tree(char * symbname, int argc, ...);
//struct tree *alloc_tree(int R, ...);
#define PATHMAX 1000      // Maximum length of filepath names
#define SCAN_ERROR -3
#define PANIC -4
#define BRACKET_ERROR -5
#define EOF_ERROR -6

void check_alloc(void *obj, char *msg);
int count_dedents(int *top, int dentstack[], int indent_level, int rows);
double extract_float(char *s);
int deescape(char *dest, char *s);
int extract_int(char *s);
int extract_string(char *dest, char *s);
int get_quote_count(char *text, int len);
int is_enclosed(int p_nesting, int sq_nesting, int cb_nesting);
int panic(char *errmsg);
char *strip_underscores(char *s);
char *substring(char *s, int start, int end);
void truncate_str(char *dest, char *src, int level);
void err_t_lookahead(int yychar);
void err_lookahead(int yychar, int count, const char *msg, ...);
int yylexerror(char *s);
char *rand_string(int min_len, int max_len);
int get_rand_ascii();
#include "punygram.tab.h"

//returns name of category for category integer. may prove handy in the future.

char *rev_token(int cat){

    switch(cat)
    {
        case   FLOATLIT: return "FLOATLIT";          
        case   ENDMARKER: return "ENDMARKER";         
        case   NAME: return "NAME";              
        case   INTLIT: return "INTLIT";            
        case   STRINGLIT: return "STRINGLIT";         
        case   NEWLINE: return "NEWLINE";           
        case   INDENT: return "INDENT";            
        case   DEDENT: return "DEDENT";            
        case   LPAR: return "LPAR";              
        case   RPAR: return "RPAR";              
        case   LSQB: return "LSQB";              
        case   RSQB : return "RSQB";             
        case   COLON : return "COLON";            
        case   COMMA: return "COMMA";             
        case   SEMI: return "SEMI";              
        case   PLUS: return "PLUS";              
        case   MINUS: return "MINUS";             
        case   STAR: return "STAR";              
        case   SLASH: return "SLASH";             
        case   VBAR: return "VBAR";              
        case   AMPER: return "AMPER";             
        case   LESS: return "LESS";              
        case   GREATER: return "GREATER";           
        case   EQUAL: return "EQUAL";             
        case   DOT: return "DOT";               
        case   PERCENT: return "PERCENT";           
        case   LBRACE: return "LBRACE";            
        case   RBRACE: return "RBRACE";            
        case   EQEQUAL: return "EQEQUAL";           
        case   NOTEQUAL: return "NOTEQUAL";          
        case   LESSEQUAL: return "LESSEQUAL";         
        case   GREATEREQUAL: return "GREATEREQUAL";      
        case   TILDE: return "TILDE";             
        case   CIRCUMFLEX: return "CIRCUMFLEX";        
        case   LEFTSHIFT: return "LEFTSHIFT";         
        case   RIGHTSHIFT: return "RIGHTSHIFT";        
        case   DOUBLESTAR: return "DOUBLESTAR";        
        case   PLUSEQUAL: return "PLUSEQUAL";         
        case   MINEQUAL: return "MINEQUAL";          
        case   STAREQUAL: return "STAREQUAL";         
        case   SLASHEQUAL: return "SLASHEQUAL";        
        case   PERCENTEQUAL: return "PERCENTEQUAL";      
        case   AMPEREQUAL: return "AMPEREQUAL";        
        case   VBAREQUAL: return "VBAREQUAL";         
        case   CIRCUMFLEXEQUAL: return "CIRCUMFLEXEQUAL";   
        case   LEFTSHIFTEQUAL: return "LEFTSHIFTEQUAL";    
        case   RIGHTSHIFTEQUAL: return "RIGHTSHIFTEQUAL";   
        case   DOUBLESTAREQUAL: return "DOUBLESTAREQUAL";   
        case   DOUBLESLASH: return "DOUBLESLASH";       
        case   DOUBLESLASHEQUAL: return "DOUBLESLASHEQUAL";  
        case   AT: return "AT";                
        case   ATEQUAL: return "ATEQUAL";           
        case   RARROW: return "RARROW";            
        case   ELLIPSIS: return "ELLIPSIS";          
        case   COLONEQUAL: return "COLONEQUAL";        

        case   PYFALSE: return "PYFALSE";           
        case   PYDEF: return "PYDEF";	          
        case   IF: return "IF";	              
        case   RAISE: return "RAISE";             
        case   NONE: return "NONE";	          
        case   DEL: return "DEL";	              
        case   IMPORT: return "IMPORT";	          
        case   RETURN: return "RETURN";            
        case   PYTRUE: return "PYTRUE";	          
        case   ELIF: return "ELIF";	          
        case   IN: return "IN";	              
        case   TRY: return "TRY";               
        case   AND: return "AND";	              
        case   ELSE: return "ELSE";	          
        case   IS: return "IS";	              
        case   WHILE: return "WHILE";             
        case   AS: return "AS";	              
        case   EXCEPT: return "EXCEPT";	          
        case   LAMBDA: return "LAMBDA";	          
        case   WITH: return "WITH";              
        case   ASSERT: return "ASSERT";	          
        case   FINALLY: return "FINALLY";	          
        case   NONLOCAL: return "NONLOCAL";	      
        case   YIELD: return "YIELD";             
        case   BREAK: return "BREAK";	          
        case   FOR: return "FOR";	              
        case   NOT: return "NOT";	              
        case   CLASS: return "CLASS";	          
        case   FROM: return "FROM";	          
        case   OR: return "OR";	              
        case   CONTINUE: return "CONTINUE";	      
        case   GLOBAL: return "GLOBAL";	          
        case   PASS: return "PASS";              
        case   OP: return "OP";                
        case   AWAIT: return "AWAIT";             
        case   ASYNC: return "ASYNC";             
        case   TYPE_IGNORE: return "TYPE_IGNORE";       
        case   TYPE_COMMENT: return "TYPE_COMMENT";      
        case   ERRORTOKEN: return "ERRORTOKEN";        

        case   COMMENT: return "COMMENT";           
        case   ENCODING: return "ENCODING"; 
    }
    return "ERROR UNKNOWN CASE IN back.c, rev_token()";  
}       
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "errdef.h"
#include "symtab.h"
#include "tree.h"
#include "punygram.tab.h"
#include "utils.h"

extern int yylineno, column, chars;
extern FILE * yyin;
extern int yylex();
extern int yyparse();
extern char *yytext;
extern char *rev_token(int cat);
extern int paren_nesting, sqbr_nesting, cbr_nesting;
extern int firsttime;
extern YYSTYPE yylval;
extern tree_t* tree;
// For debugging
extern int indent_count, dedent_count;
extern int make_tree_count, alctoken_count;
//void dealloc_list(struct tokenlist *l);

extern char yyfilename[PATHMAX];
void print_list(tokenlist_t *l);
//int insert_node(tokenlist_t **l, double dval, char *sval, int ival, char *text, int cat, int rows, char *filename);
void dealloc_list(tokenlist_t *l);

int main(int argc, char *argv[]) {

    bool symtab_opt = false; // Should we print symbol table?
    bool tree_opt = false;   // Should we print the tree?

    for(int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-symtab") == 0) {
            symtab_opt = true;
            continue;
        } else if(strcmp(argv[i], "-tree") == 0) {
            tree_opt = true;
            continue;
        }
        if (access(argv[i], F_OK) == 0 && strstr(argv[i], ".py")) { // Check if file exists and has .py extension
            yyin = fopen(argv[i], "rb");
            strcpy(yyfilename, argv[i]);
            if (yyin == NULL) { // Check that file is opened correctly
                fprintf(stderr, "File %s cannot be opened\n", argv[i]);
                continue;
            }
            printf("File: %s\n", yyfilename);
        } else {
            fprintf(stderr, "Skipping %s. Not a .py file or does not exist\n", argv[i]);
            continue;
        }
        // Reset global variables at the beginning of each file
        yylineno = 1;
        column = 1;
        paren_nesting = sqbr_nesting = cbr_nesting = 0;
        firsttime = 0;
        indent_count = dedent_count = 0;

        /** Parse */
        yyparse();

        /** Initialize SymbolTable Stack with HASH_TABLE_SIZE buckets */
        SymbolTable global = mksymtab(HASH_TABLE_SIZE, "global"); 
        if(global == NULL) {
            fprintf(stderr, "Unable to allocate symbol table\n");
            exit(SEM_ERR); // Cuz semantic error, right?
        }

        if(tree_opt) {
            print_tree(tree, 0);
        }
        semantics(tree, global);
        if(symtab_opt) {
            printsymbols(global, 0);
        }
        printf("No errors.\n");
        free_tree(yylval.treeptr);
        free_symtab(global);
        fclose(yyin);
    }

    return 0;
}
#include "tree.h"
#include <stdio.h>
#include <stdlib.h>
#include "punygram.tab.h"

void printsymbol(char *s);

void printsyms(struct tree *t)
{
    if(t == NULL)
        return;
    if(t->nkids > 0) {
        for(int i = 0; i<t->nkids; i++)
            printsyms(t->kids[i]);
    } else {
        if(t->leaf->category == NAME)
            printsymbol(t->leaf->text);
    }
}

void printsymbol(char *s)
{
   printf("%s\n", s); fflush(stdout);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "errdef.h"
#include "punygram.tab.h"
#include "symtab.h"
#include "tree.h"

extern tree_t* tree;

// Populate symbol tables from AST
void populate_symboltables(struct tree *t, SymbolTable st) {
    if (t == NULL) {
        return;
    }
    // For functions, we add the name of the function to the current symbol 
    // table, then create a symbol table for the function.
    if(strcmp(t->symbolname, "funcdef") == 0) {
        insertsymbol(st, t->kids[0]->leaf->text, t->kids[0]->leaf->lineno);
        insertfunction(t, st);
        return;
    } else if(strcmp(t->symbolname, "classdef") == 0) {
        insertsymbol(st, t->kids[0]->leaf->text, t->kids[0]->leaf->lineno);
        insertclass(t, st);
        return;
    } else if(strcmp(t->symbolname, "global_stmt") == 0) {
        SymbolTable global = get_global_symtab(st);
        add_global_names(global, t);
    } else if(strcmp(t->symbolname, "expr_stmt") == 0) {
        get_assignment_symbols(t, st);
        //insertsymbol(st, t->leaf->text, t->leaf->lineno);
    } 
    for(int i = 0; i < t->nkids; i++) {
        populate_symboltables(t->kids[i], st);
    }
}


void semantics(struct tree *t, SymbolTable st)
{
    add_puny_builtins(st);
    populate_symboltables(t, st);
    locate_undeclared(t, st);
}

/**
 * Assumption: symbol table is populated
 */
void locate_undeclared(struct tree *t, SymbolTable st)
{
    if(t == NULL || st == NULL) 
        return;
    if(strcmp(t->symbolname, "NAME") == 0) {
        //printf("%s\n", t->leaf->text);
        check_decls(t, st);
    }
    for(int i = 0; i < t->nkids; i++) {
        if(t->stab != NULL) 
            locate_undeclared(t->kids[i], t->stab);
        else
            locate_undeclared(t->kids[i], st);
    }
}


/**
 * Assumption: symbol is NAME
 */
void check_decls(struct tree *t, SymbolTable st)
{
    char *ident = t->leaf->text;
    if(st == NULL) { // It couldn't be found (global->parent = NULL)
        fprintf(stderr, "Name '%s' not defined\n", ident);
        exit(SEM_ERR);
    }
    uint h = hash(st, ident);
    //printf("h: %d\n", h);
    SymbolTableEntry e = NULL;
    for(e = st->tbl[h]; e != NULL; e = e->next) {
        if(strcmp(e->ident, ident) == 0) {
            // Found identifier in hash table
            if(e->lineno <= t->leaf->lineno) {
                //printf("e->llineno: %d\t t lineno: %d\n", e->lineno, t->leaf->lineno);
                return;
            }
        }
    }
    if(e == NULL) {
        check_decls(t, st->parent);
    }
}


/**
 * We're assuming that st is the global symbol table
 */
void add_global_names(SymbolTable st, tree_t *t)
{
    if(t->nkids == 0) {
        return;
    }
    if(strcmp(t->kids[0]->symbolname, "NAME") == 0) {
        insertsymbol(st, t->kids[0]->leaf->text, t->kids[0]->leaf->lineno);
        add_global_names(st, t->kids[1]);
    }
    else {
        insertsymbol(st, t->kids[1]->leaf->text, t->kids[1]->leaf->lineno);
        add_global_names(st, t->kids[0]);
    }
}

/**
 * Insertfunction: Unlike insertsymbol, overwrite any previous definitions of 
 * s in the table. This means free the nested symbol table. populate_symboltables
 * will recursively descend through the tree to collect identifiers for its 
 * local scope.
 * Assumptions: The first child should contain the function name
 */
void insertfunction(struct tree *t, SymbolTable st)
{
    if(st == NULL)
        return;
    char *name = t->kids[0]->leaf->text;
    int idx = hash(st, name);
    SymbolTableEntry e = NULL, entry = NULL, prev = NULL;
    for(e = st->tbl[idx]; e != NULL; prev = e, e = e->next) {
        if(strcmp(e->ident, name) == 0) {
            // If new function definition found, overwrite previous nested table
            entry = e;
            free_symtab(entry->nested);
            entry->nested = mknested(HASH_TABLE_SIZE, st, "function");
            t->stab = entry->nested;
            get_function_params(t->kids[1], entry->nested); // Add parameters 
            //populate_symboltables(t->kids[2], entry->nested); // Add rarrow test
            populate_symboltables(t->kids[3], entry->nested); // Add suite
            return;
        }
    }
    entry = calloc(1, sizeof(SymbolTableEntry));
    entry->nested = mknested(HASH_TABLE_SIZE, st, "function"); // make symbol table for function scope
    t->stab = entry->nested;
    populate_symboltables(t->kids[1], entry->nested); // Add parameters 
    //populate_symboltables(t->kids[2], entry->nested); // Add rarrow test
    populate_symboltables(t->kids[3], entry->nested); // Add suite

    if(prev != NULL) {
        prev->next = entry;
    }
}

/**
 * Starting from the parameters rule, navigate to fpdef_equal_test_comma_rep,
 * then recurse through the 
 */
void get_function_params(struct tree *t, SymbolTable ftable)
{
    if(t == NULL || ftable == NULL)
        return;
    if(strcmp(t->symbolname, "fpdef") == 0) {
        if(t->kids[0]->leaf != NULL) 
            insertsymbol(ftable, t->kids[0]->leaf->text, t->kids[0]->leaf->lineno);
    }
    else {
        for(int i = 0; i < t->nkids; i++) {
            get_function_params(t->kids[i], ftable);
        }
    }
}

/**
 * Starting subtree is expr_stmt
 */
void get_assignment_symbols(struct tree *t, SymbolTable st)
{
    if(t == NULL || st == NULL)
        return;
    if(strcmp(t->symbolname, "power") == 0) {
        if(t->kids[0]->leaf != NULL && strcmp(t->kids[0]->symbolname, "NAME") == 0
                && (t->nkids == 1 || strcmp(t->kids[1]->symbolname, "trailer_rep") != 0)) {
            insertsymbol(st, t->kids[0]->leaf->text, t->kids[0]->leaf->lineno);
        }
    }
    else {
        for(int i = 0; i < t->nkids; i++) {
            if(strcmp(t->kids[i]->symbolname, "equal_OR_yield_OR_testlist_rep") != 0) {
                get_assignment_symbols(t->kids[i], st);
                return;
            }
        }
    }
}

void insertclass(struct tree *t, SymbolTable st)
{
    if(st == NULL)
        return;
    char *name = t->kids[0]->leaf->text;
    int idx = hash(st, name);
    SymbolTableEntry e = NULL, entry = NULL, prev = NULL;
    for(e = st->tbl[idx]; e != NULL; prev = e, e = e->next) {
        if(strcmp(e->ident, name) == 0) {
            // If new class definition found, overwrite previous nested table
            entry = e;
            free_symtab(entry->nested);
            entry->nested = mknested(HASH_TABLE_SIZE, st, "class");
            t->stab = entry->nested;
            populate_symboltables(t->kids[1], entry->nested); // Add parameters 
            populate_symboltables(t->kids[2], entry->nested); // Add suite
            return;
        }
    }
    entry = calloc(1, sizeof(SymbolTableEntry));
    entry->nested = mknested(HASH_TABLE_SIZE, st, "class"); // make symbol table for function scope
    t->stab = entry->nested;
    populate_symboltables(t->kids[1], entry->nested); // Add parameters 
    populate_symboltables(t->kids[2], entry->nested); // Add suite

    if(prev != NULL) {
        prev->next = entry; // Connect linked list in case of collision
    }
}

SymbolTable get_global_symtab(SymbolTable st) 
{
    SymbolTable curr = st;
    while(curr->parent != NULL) {
        curr = curr->parent;
    }
    return curr;
}


uint hash(SymbolTable st, char *s) {
    register uint h = 5381;
    register char c;
    while((c = *s++)) {
        h = (((h << 5) + h) ^ h) + c;
    }
    return h % st->nBuckets;
}

// Create a new symbol table
SymbolTable mksymtab(int nbuckets, char *scope)
{
    SymbolTable rv;
    rv = calloc(1, sizeof(struct sym_table));
    if(rv == NULL)
        return NULL;
    rv->tbl = calloc(nbuckets, sizeof(struct sym_entry *));
    rv->nBuckets = nbuckets;
    rv->nEntries = 0;
    rv->parent = NULL;
    rv->scope = strdup(scope);
    return rv;
}


// Create a symbol table for functions/classes
SymbolTable mknested(int nbuckets, SymbolTable parent, char *scope)
{
    if(strcmp(parent->scope, "function") == 0) {
        fprintf(stderr, "Function nesting not allowed in puny\n");
        exit(SEM_ERR);
    }
    SymbolTable ftable = mksymtab(nbuckets, scope);
    ftable->level = parent->level + 1;
    ftable->parent = parent;
    return ftable;
}

/**
 * Accept the current symbol table and the name of the symbol.
 * Create SymbolTableEntry for the NAME. Add the current table to the entry.
 * Set the relevant fields (s, next, st->tbl[idx])
 */
int insertsymbol(SymbolTable st, char *s, int lineno) {
    if(st == NULL)
        return 0;
    int idx = hash(st, s);
    SymbolTableEntry prev = NULL;
    for (SymbolTableEntry e = st->tbl[idx]; e != NULL; prev = e, e = e->next) {
        if (strcmp(e->ident, s) == 0) {
            return 0;
        }
    }
    SymbolTableEntry entry = calloc(1, sizeof(struct sym_entry));
    entry->table = st;
    entry->ident = strdup(s);
    entry->lineno = lineno;
    entry->next = NULL;
    if(prev != NULL)
        prev->next = entry;
    else
        st->tbl[idx] = entry;
    //printf("%s\n", entry->ident);
    st->nEntries++;
    return 1;
}


// Helper function to find a symbol in a symbol table
SymbolTableEntry findsymbol(SymbolTable st, char *s)
{
    int h;

    h = hash(st, s);
    for(SymbolTableEntry entry = st->tbl[h]; entry != NULL; entry = entry->next) {
        if(strcmp(s, entry->ident) == 0) {
            /* Return a pointer to the symbol table entry. */
            return entry;
        }
    }
    return NULL;
}

void printsymbols(SymbolTable st, int level)
{
    int i;
    if (st == NULL) return;
    for (i = 0; i < st->nBuckets; i++) {
        for(SymbolTableEntry entry = st->tbl[i]; entry != NULL; entry = entry->next) {
            for(int j = 0; j < entry->table->level; j++) {
                printf("  ");
            }
            printf("%d: %s\n", i, entry->ident);
            if(entry->nested != NULL) {
                printsymbols(entry->nested, level + 1);
            }
        }
    }
}

void free_symtab(SymbolTable st) {
    if (st == NULL) {
        return;
    }

    // Free symbol entries
    for (int i = 0; i < st->nBuckets; i++) {
        SymbolTableEntry entry = st->tbl[i];
        while (entry != NULL) {
            SymbolTableEntry next_entry = entry->next;

            // Free nested symbol table
            if (entry->nested != NULL) {
                free_symtab(entry->nested);
            }

            // Free entry attributes
            if (entry->ident != NULL) {
                free(entry->ident);
            }

            // Free entry
            free(entry);

            entry = next_entry;
        }
    }

    // Free referenced but not declared variables
    SymbolTableEntry ref_entry = st->references;
    while (ref_entry != NULL) {
        SymbolTableEntry next_ref_entry = ref_entry->next;

        // Free entry attributes
        if (ref_entry->ident != NULL) {
            free(ref_entry->ident);
        }

        // Free entry
        free(ref_entry);

        ref_entry = next_ref_entry;
    }

    // Free the table array and table attributes
    if (st->tbl != NULL) {
        free(st->tbl);
    }
    if (st->scope != NULL) {
        free(st->scope);
    }

    // Free the symbol table itself
    free(st);
}


void add_puny_builtins(SymbolTable st) {
    insertsymbol(st, "print", -1);
    insertsymbol(st, "int", -1);
    insertsymbol(st, "abs", -1);
    insertsymbol(st, "bool", -1);  
    insertsymbol(st, "chr", -1);
    insertsymbol(st, "dict", -1);
    insertsymbol(st, "float", -1);
    insertsymbol(st, "input", -1);
    insertsymbol(st, "int", -1);    
    insertsymbol(st, "len", -1);
    insertsymbol(st, "list", -1);
    insertsymbol(st, "max", -1);
    insertsymbol(st, "min", -1);
    insertsymbol(st, "open", -1);
    insertsymbol(st, "ord", -1);
    insertsymbol(st, "pow", -1);
    insertsymbol(st, "print", -1);
    insertsymbol(st, "range", -1);
    insertsymbol(st, "round", -1);
    insertsymbol(st, "str", -1);
    insertsymbol(st, "type", -1);
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include "punygram.tab.h"
#include "tree.h"
#include "utils.h"

extern char *rev_token(int cat);
extern char *yytext;
extern YYSTYPE yylval;
extern int yylineno;
extern int column;

// ### DEBUGGING ### //
int indentation_level = 0; 
int max_indent = 0;
int indent_count = 0;
int dedent_count = 0;
int make_tree_count = 0, alctoken_count = 0;

// Current filename
char yyfilename[PATHMAX];

/** Find the row the token starts on
 */ 
int get_lineno(char *text, int rows)
{
    int newlines = 0;
    int len = strlen(text);
    for(int i = 0; i < len; i++) {
        if(text[i] == '\n')
            newlines++;
    }
    return rows - newlines;
}


/** Get column token starts on 
 */
int get_column(char *text, int column)
{
    int charcount = 0;
    int len = strlen(text);
    for(int i = len - 1; i >= 0; i--) {
        if(text[i] == '\n')
            break;
        else
            charcount++;
    }
    return column - charcount;
}

/** Allocate token that will eventually be placed into the syntax tree
 */
int alctoken(int category)
{
    alctoken_count++;
    int text_len = strlen(yytext);
    yylval.treeptr = malloc(sizeof(tree_t));
    check_alloc(yylval.treeptr, "yylval.treeptr");
    
    int i = 0;
    while(i<9)
    {yylval.treeptr->kids[i] = NULL;i++;}
    
    yylval.treeptr->prodrule = category;
    yylval.treeptr->nkids = 0;
    yylval.treeptr->leaf = malloc(sizeof(token_t));
    check_alloc(yylval.treeptr->leaf, "yylval.treeptr->leaf");
    yylval.treeptr->leaf->category = category;
    yylval.treeptr->leaf->lineno = yylineno;
    char *name = rev_token(category);
    yylval.treeptr->symbolname = malloc(strlen(name)+1);
    check_alloc(yylval.treeptr->symbolname, "yylval.treeptr->symbolname");
    yylval.treeptr->leaf->text = calloc(text_len + 1, sizeof(char));
    check_alloc(yylval.treeptr->leaf->text, "yylval.treeptr->text allocation failed");
    yylval.treeptr->leaf->filename = calloc(strlen(yyfilename) + 1, sizeof(char));
    check_alloc(yylval.treeptr->leaf->filename, "yylval.treeptr->filename allocation failed");
    strcpy(yylval.treeptr->leaf->filename, yyfilename); 
    strcpy(yylval.treeptr->leaf->text, yytext);
    strcpy(yylval.treeptr->symbolname, name);
    if(category == INTLIT) {
        yylval.treeptr->leaf->ival = extract_int(yytext);
    }
    else if(category == FLOATLIT) {
        yylval.treeptr->leaf->dval = extract_float(yytext);
    }
    else if(category == STRINGLIT) {
        yylval.treeptr->leaf->sval = calloc(strlen(yytext), sizeof(char));
        int retval = extract_string(yylval.treeptr->leaf->sval, yytext);
        if(retval < 0) {
            return retval;
        }
    }
    return category;
}


/** Liberate the tree tokens.
 *
 */
void free_tree(struct tree *t)
{
    if(t->leaf != NULL) {
        free(t->leaf->text);
        free(t->leaf->filename);
        if(t->leaf->category == STRINGLIT)
            free(t->leaf->sval);
        free(t->leaf);
    }
    for(int i = 0; i < t->nkids && t->kids[i] != NULL; i++) {
        free_tree(t->kids[i]);
    }
    if(t->symbolname != NULL) {
        free(t->symbolname);
    }
    free(t);
}


/**
 * @return zero if everything executes correctly or nonzero if error printing
 */
int print_token(token_t *t)
{
    if(t == NULL) {
        return 1;
    }
    char truncated_text[TEXT_TRUNCATION_LEVEL+1] = "";
    truncate_str(truncated_text, t->text, TEXT_TRUNCATION_LEVEL);
    printf("%s\t\t\t%s\t\t%d\t\t%d\t\t%s\t\t", rev_token(t->category), truncated_text, t->lineno, t->column, t->filename);
    if(t->category == INTLIT)
        printf("%d\n", t->ival);
    else if(t->category == FLOATLIT)
        printf("%f\n", t->dval);
    else if(t->category == STRINGLIT) {
        char truncated_str[TEXT_TRUNCATION_LEVEL+1] = "";
        truncate_str(truncated_str, t->sval, TEXT_TRUNCATION_LEVEL);
        printf("%s\n", truncated_str);
    }
    else
        printf("\n");
    if(t->category == INDENT) {
        indentation_level++;
        indent_count++;
        if(indentation_level > max_indent) {
            max_indent = indentation_level;
        }
        printf("\tINDENTATION LEVEL: %d\n", indentation_level);
        printf("\tINDENT COUNT: %d\tDEDENT COUNT: %d\n", indent_count, dedent_count);
        printf("\tMAX INDENT: %d\n", max_indent);
    }
    else if(t->category == DEDENT) {
        dedent_count++;
        indentation_level--;
        printf("\tINDENTATION LEVEL: %d\n", indentation_level);
        printf("\tINDENT COUNT: %d\tDEDENT COUNT: %d\n", indent_count, dedent_count);
        printf("\tMAX INDENT: %d\n", max_indent);
    }
    return 0;
}

struct tree* append_kid(struct tree * kidspassed[], char * symbnam)
{
    int i = 0;
    struct tree *newtree = malloc(sizeof(tree_t));
    newtree->symbolname = malloc(strlen(symbnam) + 1);
    strcpy(newtree->symbolname, symbnam);
    while(i<9)
    {
        newtree->kids[i]=NULL;
        i++;
    }

    i=0;

    newtree->leaf = NULL;
    newtree->prodrule = 0;
    
    while(i < 9 && kidspassed[i] != NULL)
    {
        newtree->kids[i] = kidspassed[i];
        i++;
    }
    newtree->nkids = i;
    return newtree;
}


struct tree* make_tree(char * symbname, int argc, ...)
{
    make_tree_count++;
    va_list ap;
    va_start(ap, argc);
    int i = 0;
    struct tree *kids[9];
    while(i<9) // Initializing to keep valgrind happy
    {
        kids[i] = NULL;
        i++;
    }

    i = 0;
    while((argc-i)>0)
    {
        kids[i] = va_arg(ap, struct tree *);
        i++;
    }
    va_end(ap);

    return append_kid(kids, symbname);   
}


char *get_spaces(int n)
{
    char *s = malloc(n+1);
    int i = 0; 
    while(i<n)
    {
        s[i] = ' ';
        i++;
    }
    s[i] = '\0';
    return s;
}


void print_tree(struct tree * t, int depth)
{  // printf("entering print tree\n");
    char * spcs = get_spaces(depth);
    if(strcmp(t->symbolname,"nulltree")==0)
    {
        //printf("NULLTREE \n");
        free(spcs);
        return;
    }
    //printf("about to check if leaf is null\n");
    if(t->leaf != NULL)
    {   //printf("finna print leaf info\n");
        printf("%s%d-LEAF category: %d, category: %s, value: %s\n",spcs,depth, t->leaf->category, rev_token(t->leaf->category), t->leaf->text);
        free(spcs);
        return;
    }
    //printf("somehow past leaf print\n");
    
    if(t->kids[0]==NULL)
    {   //printf("kids are null\n");
        if(t->symbolname != NULL)
        {
            //printf("leaf depth %d\n",depth);
            printf("%s%d-LEAF: symbname: %s\n", spcs, depth, t->symbolname);
        }
        free(spcs);
        return;
    }
    //printf("see if symbname is null\n");

    if(t->symbolname != NULL)
    {   //printf("somehow made it past this\n");
        printf("%s%d-INNER: symbname: %s\n", spcs, depth, t->symbolname); 
        //printf("existence has concluded in segmentation fault\n");
    }
    int i = 0;

    while(i < 9 && t->kids[i] != NULL)
    {   
        //printf("inner depth %d\n",depth);
        print_tree(t->kids[i], depth+1);
        i++;
    }
    free(spcs);
    return;
}


/** printsyms
 */
void printsyms(struct tree *t)
{
    if(t == NULL) return;
    if(t->nkids > 0) {
        int i;
        for(i = 0; i < t->nkids; i++) printsyms(t->kids[i]);
    }
    else {
        if(t->leaf->category == NAME) printsymbol(t->leaf->text);
    }
}


void printsymbol(char *s)
{
    printf("%s\n", s); fflush(stdout);
}


/** Display list contents
 * @param l the head of the list
 */
void print_list(tokenlist_t *l)
{
	tokenlist_t *curr = l;
    printf("\n");
    if(l != NULL) {
        printf("Category\t\tText\tLineno\tColumn\tFilename\tIval/Sval\n");
        for(int i = 0; i < 80; i++) printf("-");
        printf("\n");
    }
    else {
        printf("Token list is empty.\n");
    }
	while(curr != NULL) { 
        if(print_token(curr->t) == 0)
            curr = curr->next;
        else
            break;
	}
}

#include <assert.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <time.h>
#include "punygram.tab.h"
#include "utils.h"

extern char yyfilename[];
extern int yylineno;
extern char *yytext;
extern char *rev_token(int);
extern YYSTYPE yylval;

int get_ascii(char c)
{

	switch(c){
		case 'n': 
			return '\n';
			break;

		case 'a':
			return '\a';
			break;

		case 'f': 
			return '\f';
			break;

		case 'r': 
			return '\r';
			break;

		case 't': 
			return '\t';
			break;			

		case '\\': 
			return '\x5c';
			break;

		case '\'': 
			return '\x27';
			break;

		case '"': 
			return '"';
			break;
		default:
			return -1;

		}
}

/** Return error code
 */
int panic(char *errmsg)
{
	printf("%s",errmsg);
    return PANIC;
}

/** Accepts string buffer to be written to. 
 * @return an integer that is 0 if everything executes properly. Return nonzero 
 * to indicate failure. This gives the process a chance to deallocate the list
 */
int deescape(char *dest, char *s)
{   
    int temp_index = 0;
    int s_index = 0;
    while(s[s_index] != '\0')
    {
        if(s[s_index] == '\\')
        {
            s_index++;
            if(!isdigit(s[s_index]))
            {	
            	if((dest[temp_index] = get_ascii(s[s_index])) > 0)
            	{	
            		temp_index++;
            		s_index++;
            		continue;
            	}
            	else
            	{
                    free(s);
            		return panic("error in deescape, invalid escape character\n");	
            	}
            }
            else
            {
            	if((s_index + 2) < strlen(s) && (isdigit(s[s_index+1])) && isdigit(s[s_index+2]))
            	{
            		//build value on the spot, rather quick and dirty

            		int d3 = s[s_index]-48; //'0' has ascii value 48, so subtract that to get numerical val
            		int d2 = s[s_index+1]-48;
            		int d1 = s[s_index+2]-48;

					printf("OCTAL DIGITS %d %d %d\n", d3, d2, d1);

            		if(d3<8 && d2 <8 && d1<8){
            			dest[temp_index] = d3*8*8 + d2*8 + d1;
            			s_index += 3;
            			temp_index++;
            			continue;
            			}
            		else
            		{
                        free(s);
            			return panic("possibly invalid octal in de-escape\n");
            		}	

            	}
            	else
            	{
                    free(s);
            		return panic("ERROR de-escaping character\n");
            	}
                if((dest[temp_index] = get_ascii(s[s_index])) > 0)
                {   
                    temp_index++;
                    s_index++;
                    continue;
                }
                else
                {
                    printf("error in deescape, invalid escape character\n");
                    free(s);
                    return -1;   
                }
            }
        }

        dest[temp_index] = s[s_index];

        temp_index++;
        s_index++;
    }
    dest[temp_index] = '\0';

    return 0;
}
char *substring(char *s, int start, int end)
{	
    int i = 0;
    int length = end - start;
    char *ret = calloc(length + 1, sizeof(char));
    while (i < length) {
        ret[i] = s[i + start];
        i++;
    }
    //ret[i] = '\0';
    return ret;
}

int extract_string(char *dest, char *s)
{	
	//check if empty string, then return such
    int ret = 0;
	if(strcmp(s, "\"\"") == 0 || strcmp(s, "\'\'") == 0) 
	{
		dest[0] = '\0';
		return ret;
	}
    int start = 0;
    int end = strlen(s);
    if (s[1] == '"') {
        start = 2;
        end = end - 2;
    } else if (s[1] == '\'') {
        start = 2;
        end = end - 2;
    } else {
        start = 1;
        end = end - 1;
    }

    char *temp =  substring(s, start, end);
	return deescape(dest, temp);
}

char *strip_underscores(char *s)
{
    int length = strlen(s);
    char *temp = malloc(sizeof(char) * (length + 1));
    int temp_index = 0;
    for (int i = 0; i < length; i++) {
        if (s[i] == '_') {
            continue;
        }
        temp[temp_index++] = s[i];
    }
    temp[temp_index] = '\0';
    return temp;
}

/** Generate a string with three dots at the end to indicate truncation
 * at the specified level
 */
void truncate_str(char *dest, char *src, int level)
{
    strncpy(dest, src, level);
    int i;
    for(i = 0; i < level - 3; i++) {
        if(dest[i] == '\n')
            dest[i] = ' ';
    }
    for(i = level - 3; i < level; i++) dest[i] = '.';
}

int get_quote_count(char *text, int len)
{
    char quote_char = text[0];
    if(text[1] != quote_char || len == 2) {
        return 1;
    }
    return 3;
}

int extract_int(char *s)
{
    char *stripped = strip_underscores(s);
    int ret = strtoul(stripped, NULL, 0);
    free(stripped);
    return ret;
}

double extract_float(char *s)
{
    char *stripped = strip_underscores(s);
    double ret = strtod(stripped, NULL);
    free(stripped);
    return ret;
}

/** Count dedent function used for two regexes.
 * Return SCAN error if something goes wrong, which will signal an error in 
 * punylex.l
 * @param top pointer to top variable in punylex
 * @param dentstack the indentation stack
 * @param indent_level the calculated indentation level
 * @param rows the current row count
 * @return number of dedents
 */
int count_dedents(int *top, int dentstack[], int indent_level, int rows) 
{
    int dedents = 0;
    while(*top > 0 && dentstack[*top] > indent_level) {
        dedents++; (*top)--;
    }
    if(dentstack[*top] != indent_level) {
        fprintf(stderr, "Python indent error line %d\n", rows);
        fflush(stderr);
        return -1;
    }
    return dedents;
}

/** Determine whether the scanner is inside of brackets
 * @return whether there are unclosed parentheses or brackets
 */
int is_enclosed(int p, int sq, int cb)
{
    return (p > 0) || (sq > 0) || (cb > 0);
}

/** Error printing for syntax errors
 * TODO: Make better error handling
 */
int yyerror(char *s)
{
    fprintf(stderr, "%s:%d: SyntaxError: %s before '%s' token\n", yyfilename, yylineno, s, yytext);
    exit(2);
}

/* Lexical error handling
 */
int yylexerror(char *s)
{
    fprintf(stderr, "%s:%d: Lexical error: %s before '%s' token\n", yyfilename, yylineno, s, yytext);
    exit(1);
}

/** Prints error message and exits if given object is null
 * @param obj pointer to some data
 * @param msg message
 */
void check_alloc(void *obj, char *msg)
{
    if(obj == NULL) {
        fprintf(stderr, "Could not allocate memory for '%s'", msg);
        exit(1);
    }
}

/** Generate syntax error for t_lookahead in grammar
 */
void err_t_lookahead(int yychar)
{
    if(yychar == LPAR || yychar == LSQB || yychar == DOT) {
        printf("t_primary forbidden lookahead\n");
        exit(1);
    }
}

void err_lookahead(int yychar, int count, const char *buf, ...)
{
    va_list args;
    va_start(args, buf);
    int token;
    for(int i = 0; i < count; i++) {
        token = va_arg(args, int);
        if(yychar == token) {
            fprintf(stderr, "Syntax error near '%s' token\n", rev_token(token));
        }
    }
    va_end(args);
}

/** Generate a random string of length len
 * For debugging hash table and maybe other stuff
 */
char *rand_string(int min_len, int max_len)
{
    assert(min_len > 0);
    int n = rand() % max_len;
    n = n >= min_len ? n : n + min_len;
    char *out = calloc(n + 1, sizeof(char));
    for(int i = 0; i < n; i++) {
        out[i] = get_rand_ascii();
    }
    return out;
}

int get_rand_ascii()
{
    int lower = '!', upper = '~';
    char res = rand() % upper;
    return res >= lower ? res : res + lower;
}
/* -*-bison-*- */
/* Simple wc implementation in Flex */
%option noyywrap
%option noinput
%option nounput

%{
#include "tree.h"
#include "punygram.tab.h"
#include "utils.h"
int dentstack[100]={0};
int top=0;
int indentlevel(char *s);		
int words = 0, column=0;
int dedentcount;
int firsttime;
int has_endmarker_been_returned = 0;
// Are the indent/dedents inside of brackets or parentheses?
int paren_nesting = 0, sqbr_nesting = 0, cbr_nesting = 0; 
extern int yylineno;
extern int yyerror(char *s);
extern char *puny_support_err;

#define yylex real_yylex			
%}

multiline_double_quotes     ["]{3}(["]{0,2}([^\\"]|\\(.|\n)))*["]{3}
multiline_single_quotes     [']{3}([']{0,2}([^\\']|\\(.|\n)))*[']{3}
double_quotes               \"[^"\n]*\"
single_quotes               \'[^'\n]*\'
stringlit                   {multiline_double_quotes}|{multiline_single_quotes}|{double_quotes}|{single_quotes}
fstring                     "f"{stringlit}
rstring                     "r"{stringlit}
int_dec                     [1-9](_?[0-9])*
int_hex                     0x_?([0-9a-fA-F](_[0-9a-fA-F])*)*
int_octal                   0o[0-7]+
integer                     {int_dec}|{int_hex}|0+
float_noexp                 ([0-9]+(_?[0-9])*\.[0-9]*(_?[0-9])*)|([0-9]*(_?[0-9])*\.[0-9]+(_?[0-9])*)
float                       {float_noexp}|(({float_noexp}|([0-9]+(_?[0-9])*))[eE][+-]?[0-9]+(_?[0-9])*)
comment                     #+[^\n]*
%%

{comment}			{ column += strlen(yytext); } // comments
<<EOF>>             { 
                        if(firsttime++ == 0) {
                            int il = 0;
                            dedentcount = count_dedents(&top, dentstack, il, yylineno);
                            if(dedentcount == SCAN_ERROR) {
                                yylexerror("indentation error");
                            }
                            if(is_enclosed(paren_nesting, sqbr_nesting, cbr_nesting)) {
                                yyerror("Unexpected EOF");
                            }
                            return alctoken(NEWLINE); 
                        }
                        else {
                            // We return an extra newline at the end for the grammar
                            if(has_endmarker_been_returned) {
                                return -1;
                            }
                            has_endmarker_been_returned = 1;
                            return alctoken(ENDMARKER); 
                        }
                    }
\\\n		        { yylineno++; column =1; }
\n[ \t]*{comment}   { yylineno++; }
\n/[^ \t\n\r]         { 
                        yylineno++; column=1; 
                        int il = 0;
                        if(il < dentstack[top]) {
                             dedentcount = count_dedents(&top, dentstack, il, yylineno);
                             if(dedentcount == SCAN_ERROR && !is_enclosed(paren_nesting, sqbr_nesting, cbr_nesting)) {
                                 yylexerror("indentation error");
                             }
                        }
                        if(!is_enclosed(paren_nesting, sqbr_nesting, cbr_nesting)) // 
                            return alctoken(NEWLINE); // Only returning newlines not enclosed within braces, curlies, or parentheses
                    }
\n[ \t]+/[^ \t\n\r]   { 	
                        yylineno++; 
                        int il = indentlevel(yytext+1);
                        column=il+1;
                        if(!is_enclosed(paren_nesting, sqbr_nesting, cbr_nesting)) {
                            if (il > dentstack[top]) {
                                dentstack[++top] = il;
                                /* return an INDENT token, except NEWLINE first */
                                dedentcount = -1;
                            }
                            else if (il < dentstack[top]) {
                                /* return one or more DEDENT tokens */
                                dedentcount = count_dedents(&top, dentstack, il, yylineno);
                                if(dedentcount == SCAN_ERROR) {
                                    yylexerror("indentation error");
                                }
                                /* need to dedent by dedentcount, but returning NEWLINE */
                            }
                            else {
                                /* still at ILEVEL il, no INDENT or DEDENT */
                            
                            }
                            return alctoken(NEWLINE); 
                        }
                    }
^[ \t]+                 {
                            if(yylineno == 1) {
                                yyerror("Indentation on line 1");
                            }
                            column += strlen(yytext);
                        }

\n[ \t]*/\n				{ 
                            int len = strlen(yytext); 
                            yylineno++; 
                            column = len > 1 ? len - 1 : 1; 
                            //if(!is_enclosed(paren_nesting, sqbr_nesting, cbr_nesting))
                             //   return NEWLINE;
                        }

"False"                { column += strlen(yytext); words++; return alctoken(PYFALSE); }
"def"       	       { column += strlen(yytext);words++; return alctoken(PYDEF); } 
"if"  	               { column += strlen(yytext);words++; return alctoken(IF); }
"raise"                { yylexerror(puny_support_err); }
"None"                 { column += strlen(yytext);words++; return alctoken(NONE); }
"del"                  { column += strlen(yytext);words++; return alctoken(DEL); }
"import"               { column += strlen(yytext);words++; return alctoken(IMPORT); }
"return"               { column += strlen(yytext);words++; return alctoken(RETURN); }
"True"                 { column += strlen(yytext);words++; return alctoken(PYTRUE); }
"elif"                 { column += strlen(yytext);words++; return alctoken(ELIF); }
"in"                   { column += strlen(yytext);words++; return alctoken(IN); }
"try"                  { yylexerror(puny_support_err); }
"and"                  { column += strlen(yytext);words++; return alctoken(AND); }
"else"                 { column += strlen(yytext);words++; return alctoken(ELSE); }
"is"                   { column += strlen(yytext);words++; return alctoken(IS); }
"while"                { column += strlen(yytext);words++; return alctoken(WHILE); }
"as"                   { yylexerror(puny_support_err); }
"except"               { yylexerror(puny_support_err); }
"lambda"               { yylexerror(puny_support_err); }
"with"                 { yylexerror(puny_support_err); }
"assert"               { yylexerror(puny_support_err); }
"finally"              { yylexerror(puny_support_err); }
"nonlocal"             { yylexerror(puny_support_err); }
"yield"                { yylexerror(puny_support_err); }
"break"                { column += strlen(yytext);words++; return alctoken(BREAK); }
"for"                  { column += strlen(yytext);words++; return alctoken(FOR); }
"not"                  { column += strlen(yytext);words++; return alctoken(NOT); }
"class"                { column += strlen(yytext);words++; return alctoken(CLASS); }
"from"                 { yylexerror(puny_support_err); }
"or"                   { column += strlen(yytext);words++; return alctoken(OR); }
"continue"             { column += strlen(yytext);words++; return alctoken(CONTINUE); }
"global"               { column += strlen(yytext);words++; return alctoken(GLOBAL); }


...


"del"                  { column += strlen(yytext);words++; return alctoken(DEL); }
"import"               { column += strlen(yytext);words++; return alctoken(IMPORT); }
"return"               { column += strlen(yytext);words++; return alctoken(RETURN); }
"True"                 { column += strlen(yytext);words++; return alctoken(PYTRUE); }
"elif"                 { column += strlen(yytext);words++; return alctoken(ELIF); }
"in"                   { column += strlen(yytext);words++; return alctoken(IN); }
"try"                  { yylexerror(puny_support_err); }
"and"                  { column += strlen(yytext);words++; return alctoken(AND); }
"else"                 { column += strlen(yytext);words++; return alctoken(ELSE); }
"is"                   { column += strlen(yytext);words++; return alctoken(IS); }
"while"                { column += strlen(yytext);words++; return alctoken(WHILE); }
"as"                   { yylexerror(puny_support_err); }
"except"               { yylexerror(puny_support_err); }
"lambda"               { yylexerror(puny_support_err); }
"with"                 { yylexerror(puny_support_err); }
"assert"               { yylexerror(puny_support_err); }
"finally"              { yylexerror(puny_support_err); }
"nonlocal"             { yylexerror(puny_support_err); }
"yield"                { yylexerror(puny_support_err); }
"break"                { column += strlen(yytext);words++; return alctoken(BREAK); }
"for"                  { column += strlen(yytext);words++; return alctoken(FOR); }
"not"                  { column += strlen(yytext);words++; return alctoken(NOT); }
"class"                { column += strlen(yytext);words++; return alctoken(CLASS); }
"from"                 { yylexerror(puny_support_err); }
"or"                   { column += strlen(yytext);words++; return alctoken(OR); }
"continue"             { column += strlen(yytext);words++; return alctoken(CONTINUE); }
"global"               { column += strlen(yytext);words++; return alctoken(GLOBAL); }
"pass"                 { yylexerror(puny_support_err); }
"("					   	{ column += strlen(yytext); paren_nesting++; return alctoken(LPAR); }
")"						{ 
                            column += strlen(yytext); 
                            paren_nesting--; 
                            if(paren_nesting < 0) {
                                yyerror("unmatched ')'");
                            }
                            return alctoken(RPAR); 
                        }
"["						{ column += strlen(yytext); sqbr_nesting++; return alctoken(LSQB); }
"]"						{ 
                            column += strlen(yytext); 
                            sqbr_nesting--; 
                            if(sqbr_nesting < 0) {
                                yyerror("unmatched ']'");
                            }
                            return alctoken(RSQB); 
                        }
":"						{ column += strlen(yytext); return alctoken(COLON); }
","						{ column += strlen(yytext); return alctoken(COMMA); }
";"						{ column += strlen(yytext); return alctoken(SEMI); }
"+"						{ column += strlen(yytext); return alctoken(PLUS); }
"-"						{ column += strlen(yytext); return alctoken(MINUS); }
"*"						{ column += strlen(yytext); return alctoken(STAR); }
"/"						{ column += strlen(yytext); return alctoken(SLASH); }
"|"						{ column += strlen(yytext); return alctoken(VBAR); }
"&"						{ column += strlen(yytext); return alctoken(AMPER); }
"<"						{ column += strlen(yytext); return alctoken(LESS); }
">"						{ column += strlen(yytext); return alctoken(GREATER); }
"="						{ column += strlen(yytext); return alctoken(EQUAL); }
"."						{ column += strlen(yytext); return alctoken(DOT); }
"%"						{ column += strlen(yytext); return alctoken(PERCENT); }
"{"						{ column += strlen(yytext); cbr_nesting++; return alctoken(LBRACE); }
"}"						{ 
                            column += strlen(yytext); 
                            cbr_nesting--; 
                            if(cbr_nesting < 0) { 
                                yyerror("unmatched '}'");
                            }
                            return alctoken(RBRACE); 
                        }
"=="					{ column += strlen(yytext); return alctoken(EQEQUAL); }
"!="					{ column += strlen(yytext); return alctoken(NOTEQUAL); }
"<="					{ column += strlen(yytext); return alctoken(LESSEQUAL); }
">="					{ column += strlen(yytext); return alctoken(GREATEREQUAL); }
"~"						{ column += strlen(yytext); return alctoken(TILDE); }
"^"						{ column += strlen(yytext); return alctoken(CIRCUMFLEX); }
"<<"					{ column += strlen(yytext); return alctoken(LEFTSHIFT); }
">>"					{ column += strlen(yytext); return alctoken(RIGHTSHIFT); }
"**"					{ column += strlen(yytext); return alctoken(DOUBLESTAR); }
"+="					{ column += strlen(yytext); return alctoken(PLUSEQUAL); }
"-="					{ column += strlen(yytext); return alctoken(MINEQUAL); }
"*="					{ column += strlen(yytext); return alctoken(STAREQUAL); }
"/="					{ column += strlen(yytext); return alctoken(SLASHEQUAL); }
"%="					{ column += strlen(yytext); return alctoken(PERCENTEQUAL); }
"&="					{ column += strlen(yytext); return alctoken(AMPEREQUAL); }
"|="					{ column += strlen(yytext); return alctoken(VBAREQUAL); }
"^="					{ column += strlen(yytext); return alctoken(CIRCUMFLEXEQUAL); }
"<<="					{ column += strlen(yytext); return alctoken(LEFTSHIFTEQUAL); }
">>="					{ column += strlen(yytext); return alctoken(RIGHTSHIFTEQUAL); }
"**="					{ column += strlen(yytext); return alctoken(DOUBLESTAREQUAL); }
"//"					{ column += strlen(yytext); return alctoken(DOUBLESLASH); }
"//="					{ column += strlen(yytext); return alctoken(DOUBLESLASHEQUAL); }
"@"						{ column += strlen(yytext); return alctoken(AT); yylexerror(puny_support_err); }
"@="					{ column += strlen(yytext); return alctoken(ATEQUAL); }
"->"					{ column += strlen(yytext); return alctoken(RARROW); }
"..."					{ column += strlen(yytext); return alctoken(ELLIPSIS); }
":="					{ column += strlen(yytext); return alctoken(COLONEQUAL); }

[a-zA-Z_][a-zA-Z0-9_]* { column += strlen(yytext); return alctoken(NAME); }
{integer}                 { column += strlen(yytext); return alctoken(INTLIT); }
[A-Za-z0-9]+	{column += strlen(yytext); words++; return alctoken(NAME);}
{float} { column += strlen(yytext); return alctoken(FLOATLIT); }
{fstring} { yylexerror(puny_support_err); }
{rstring}   { yylexerror(puny_support_err); }
{stringlit} {
                int len = strlen(yytext);
                char c;
                for(int i = 0; i < len; i++) {
                    c = *(yytext + i);
                    column++;
                    if(c == '\n') {
                        yylineno++;
                        column = 1;
                    }
                }
                return alctoken(STRINGLIT);
            }
.		{column++;}
\n      {column = 1; yylineno++;}
%%


int indentlevel(char *s)
{      
   int column = 1;
   while(*s == '\t' || *s == ' ') {
      if (*s == '\t') {
         while ((column % 8) != 0) column++;
      }
      else if (*s == ' ') column++;
      s++;
   }
   return column-1;
}

#undef yylex

int yylex() {
   if (dedentcount<0) {
     dedentcount++;
     return alctoken(INDENT);
     }
   if(dedentcount>0) {
     dedentcount--;
     return alctoken(DEDENT);
     }
   return real_yylex();
}



%{
    #include <stdio.h>
    #include <stdlib.h>
    #include "utils.h"
    
    #define YYDEBUG 1
    extern int yylex();
    extern int yyerror(char *);
    extern int yychar;
    extern char *yytext;
    char *puny_support_err = "This Python feature is not in puny\n";
    
    #include "tree.h"
    extern struct tree *root;

    tree_t *tree;

%}

%union {
    struct tree *treeptr;
}


%token <treeptr> FLOATLIT INTLIT STRINGLIT
%token <treeptr> ENDMARKER NEWLINE INDENT DEDENT
%token <treeptr> NAME
%token <treeptr> DOT
%token <treeptr> LPAR RPAR LSQB RSQB LBRACE RBRACE
%token <treeptr> SEMI COLON COMMA
%token <treeptr> PLUS MINUS STAR SLASH VBAR AMPER PERCENT CIRCUMFLEX TILDE LEFTSHIFT RIGHTSHIFT DOUBLESTAR AT DOUBLESLASH
%token <treeptr> LESS GREATER EQUAL
%token <treeptr> EQEQUAL NOTEQUAL LESSEQUAL GREATEREQUAL 
%token <treeptr> PLUSEQUAL MINEQUAL STAREQUAL SLASHEQUAL PERCENTEQUAL AMPEREQUAL VBAREQUAL CIRCUMFLEXEQUAL LEFTSHIFTEQUAL RIGHTSHIFTEQUAL DOUBLESTAREQUAL DOUBLESLASHEQUAL ATEQUAL COLONEQUAL
%token <treeptr> RARROW ELLIPSIS
%token <treeptr> PYTRUE PYFALSE
%token <treeptr> PYDEF CLASS
%token <treeptr> IF ELIF ELSE
%token <treeptr> DEL NONE RETURN GLOBAL
%token <treeptr> IMPORT FROM AS
%token <treeptr> TRY EXCEPT LAMBDA WITH ASSERT FINALLY NONLOCAL YIELD RAISE PASS AWAIT ASYNC// Unsupported tokens
%token <treeptr> AND OR NOT IN IS
%token <treeptr> WHILE FOR BREAK CONTINUE
%token <treeptr> OP
%token <treeptr> TYPE_IGNORE
%token <treeptr> TYPE_COMMENT
%token <treeptr> ERRORTOKEN
%token <treeptr> COMMENT
%token <treeptr> ENCODING
%token <treeptr> EMPTY
%token <treeptr> MATCH
%token <treeptr> ASSIGNMENT
%token <treeptr> DECORATOR

%type <treeptr> file_input  nl_OR_stmt_rep   stmt   simple_stmt   semi_small_stmt_rep  semi_opt  small_stmt  global_stmt   comma_name_rep   pass_stmt  del_stmt   flow_stmt   break_stmt  continue_stmt   return_stmt     yield_stmt   yield_expr  yield_expr_OR_testlist_comp   testlist_comp  tc_options  compound_stmt   classdef   lpar_testlist_rpar_opt   funcdef   parameters   varargslist_opt   varargslist   fpdef_equal_test_comma_rep   fpdef_options   equal_test_opt   com_fpdef_eq_t_rep   fpdef   fplist   comma_fpdef_rep   comma_dstar_name_opt  star_name_opt_OR_dstar_name   if_stmt   elif_test_colon_suite_rep   else_colon_suite_opt   suite   stmt_rep  while_stmt   for_stmt expr_stmt  expr_conjunct   yield_OR_testlist  equal_OR_yield_OR_testlist_rep   augassign  import_stmt   import_name   import_from   import_from_targets import_from_as_names  comma_import_from_as_name_rep   import_from_as_name  as_name_opt   dotted_as_names  comma_dotted_as_name_rep   dotted_as_name  dotted_name  dot_OR_ellipsis_rep_opt   dot_OR_ellipsis_rep  dot_OR_ellipsis     testlist_opt   testlist   comma_test_rep   exprlist   comma_expr_rep  comma_opt   expr   vbar_xor_expr_rep   xor_expr  caret_and_expr_rep  and_expr   amper_shift_expr_rep   shift_expr   shift_arith_expr_rep   shift   arith_expr  pm_term_rep   plus_OR_minus   term   factops_factor_rep   factops   factor  pmt   power   trailer_rep  trailer   arglist_opt   arglist  arg_comma_rep   arg_ORS   comma_arg_rep   comma_dstar_test_opt   argument  comp_for_opt comp_for   comp_iter_opt  comp_iter  comp_if   subscriptlist  comma_subscript_rep  subscript sliceop_opt       sliceop   test_opt   test  if_or_test_else_test_opt   or_test   or_and_test_rep  and_test  and_not_test_rep  not_test comparison  comp_op_expr_rep  comp_op  not_in   is_not  dstar_factor_opt atom  listmaker_opt listmaker  listmaker_options  list_for testlist_safe  old_test tl_safe_opt  comma_old_test_rep  list_iter_opt  list_iter list_if  dictorsetmaker_opt  dictorsetmaker  dictorset_option_1 comp_for_OR_ctctco  ctct_rep dictorset_option_2 comp_for_OR_ctr_co rarrow_test_opt colon_test_opt decl_stmt

%start file_input

%%

file_input: nl_OR_stmt_rep ENDMARKER{tree=make_tree("file_input", 1, $1);}
    ;

nl_OR_stmt_rep: {$$=make_tree("nulltree",0,NULL);}
    | nl_OR_stmt_rep NEWLINE 
    | nl_OR_stmt_rep stmt	{$$=make_tree("nl_OR_stmt_rep", 2, $1,$2);}
    ;

stmt: simple_stmt 
    | compound_stmt
    ;

simple_stmt: small_stmt semi_small_stmt_rep semi_opt NEWLINE {$$=make_tree("simple_stmt", 3, $1,$2,$3);}
    ;

semi_small_stmt_rep: {$$=make_tree("nulltree",0,NULL);}
    | semi_small_stmt_rep SEMI small_stmt {$$=make_tree("semi_small_stmt_rep", 2, $1,$3);}
    ;

semi_opt: {$$=make_tree("nulltree",0,NULL);}
    | SEMI
    ;

small_stmt: pass_stmt
    | del_stmt
    | flow_stmt
    | import_stmt
    | expr_stmt
    | global_stmt
    | decl_stmt
    //| assert_stmt {yyerror(puny_support_err); }
    ;

decl_stmt: NAME COLON NAME {$$=make_tree("decl_stmt", 2, $1, $3); }
    ;

global_stmt: GLOBAL NAME comma_name_rep {$$=make_tree("global_stmt", 2, $2,$3);}
    ;

comma_name_rep: {$$=make_tree("nulltree",0,NULL);}
    | comma_name_rep COMMA NAME {$$=make_tree("comma_name_rep", 2, $1,$3);}
    ;

pass_stmt: PASS
    ;

del_stmt: DEL exprlist {$$=make_tree("del_stmt", 1, $2);}
    ; 

flow_stmt: break_stmt
    | continue_stmt
    | return_stmt
//    | raise_stmt {yyerror(puny_support_err); }
    | yield_stmt {yyerror(puny_support_err); }
    ;

//assert_stmt: ASSERT test comma_test_opt {$$=make_tree("assert_stmt", 2,$1, $2);}
//    ;

break_stmt: BREAK
    ;

continue_stmt: CONTINUE
    ;

return_stmt: RETURN testlist_opt {$$=make_tree("return_stmt", 1, $2);}
    ;

//raise_stmt: RAISE test_triplet_opt {$$=make_tree("raise_stmt", 1, $2);}
//    ;

yield_stmt: yield_expr
    ;

yield_expr: YIELD testlist_opt {$$=make_tree("yield_expr", 1, $2);}
    ;

yield_expr_OR_testlist_comp: yield_expr
    | testlist_comp
    ;

testlist_comp: test tc_options {$$=make_tree("testlist_comp", 2,$1, $2);}
    ;

tc_options: comp_for
    | comma_test_rep comma_opt {$$=make_tree("tc_options", 2, $1, $2);}
    ;

// Compound Statements
compound_stmt: if_stmt 


...


comma_subscript_rep: {$$=make_tree("nulltree",0,NULL);}
    | comma_subscript_rep COMMA subscript {$$=make_tree("comma_subscript_rep", 2,$1,$3);}
    ;

subscript: test
    | test_opt COLON test_opt sliceop_opt {$$=make_tree("subscript", 3,$1,$3,$4);}
    ;

sliceop_opt: {$$=make_tree("nulltree",0,NULL);}
    | sliceop
    ;

sliceop: COLON test_opt{$$=make_tree("sliceop", 1,$2);}
    ;

test_opt: {$$=make_tree("nulltree",0,NULL);}
    | test
    ;

test: or_test if_or_test_else_test_opt {$$=make_tree("test", 2,$1,$2);}
    ;

if_or_test_else_test_opt: {$$=make_tree("nulltree",0,NULL);}
    | IF or_test ELSE test {$$=make_tree("if_or_test_else_test_opt", 2,$2,$4);}
    ;

or_test: and_test or_and_test_rep {$$=make_tree("or_test", 2,$1,$2);}
    ;

or_and_test_rep: {$$=make_tree("nulltree",0,NULL);}
    | or_and_test_rep OR and_test {$$=make_tree("or_and_test_rep", 2,$1,$3);}
    ;

and_test: not_test and_not_test_rep  {$$=make_tree("and_test", 2,$1,$2);}
    ;

and_not_test_rep: {$$=make_tree("nulltree",0,NULL);}
    | and_not_test_rep AND not_test {$$=make_tree("and_not_test_rep", 2,$1,$3);}
    ;

not_test: NOT not_test {$$=make_tree("not_test", 1,$2);}
    | comparison
    ;

comparison: expr comp_op_expr_rep {$$=make_tree("comparison", 2,$1,$2);}
    ; 

comp_op_expr_rep: {$$=make_tree("nulltree",0,NULL);}
    | comp_op_expr_rep comp_op expr {$$=make_tree("comp_op_expr_rep", 3,$1,$2,$3);}
    ;

comp_op: LESS
    | GREATER
    | EQEQUAL
    | GREATEREQUAL
    | LESSEQUAL
    | NOTEQUAL
    | IN
    | not_in
    | IS
    | is_not
    ;

not_in: NOT IN
    ;

is_not: IS NOT
    ;

dstar_factor_opt: {$$=make_tree("nulltree",0,NULL);}
    | DOUBLESTAR factor {$$=make_tree("dstar_factor_opt", 1,$2);}
    ;

atom: NAME 
    | INTLIT 
    | FLOATLIT
    | STRINGLIT
    | ELLIPSIS
    | NONE
    | PYTRUE
    | PYFALSE
    | LPAR yield_expr_OR_testlist_comp RPAR {$$=make_tree("atom", 1,$2);}
    | LSQB listmaker_opt RSQB {$$=make_tree("atom", 1,$2);}
    | LBRACE dictorsetmaker_opt RBRACE {$$=make_tree("atom", 1,$2);}
    ;

listmaker_opt: {$$=make_tree("nulltree",0,NULL);}
    | listmaker
    ;

listmaker: test listmaker_options {$$=make_tree("listmaker", 2,$1,$2);}
    ;

listmaker_options: list_for
    | comma_test_rep comma_opt {$$=make_tree("listmaker_options", 2,$1,$2);}
    ;

list_for: FOR exprlist IN testlist_safe list_iter_opt {$$=make_tree("list_for", 3,$2,$4,$5);}
    ;

testlist_safe: old_test tl_safe_opt {$$=make_tree("testlist_safe", 2,$1,$2);}
    ;

old_test: or_test // old lambdef just to throw an error
    ;

tl_safe_opt: {$$=make_tree("nulltree",0,NULL);}
    | comma_old_test_rep comma_opt {$$=make_tree("tl_safe_opt", 2,$1,$2);}
    ;

comma_old_test_rep: COMMA old_test {$$=make_tree("comma_old_test_rep", 1,$2);}
    | comma_old_test_rep COMMA old_test {$$=make_tree("comma_old_test_rep", 2,$1,$3);}
    ;

list_iter_opt: {$$=make_tree("nulltree",0,NULL);}
    | list_iter
    ;

list_iter: list_for
    | list_if
    ; 

list_if: IF old_test list_iter_opt {$$=make_tree("list_if", 2,$2,$3);}
    ;

dictorsetmaker_opt: {$$=make_tree("nulltree",0,NULL);}
    | dictorsetmaker
    ;

dictorsetmaker: dictorset_option_1
    | dictorset_option_2
    ;

dictorset_option_1: test COLON test comp_for_OR_ctctco {$$=make_tree("dictorset_option_1", 3,$1,$3,$4);}
    ;

comp_for_OR_ctctco: comp_for
    | ctct_rep comma_opt {$$=make_tree("comp_for_OR_ctctco", 2,$1,$2);}
    ;

ctct_rep: {$$=make_tree("nulltree",0,NULL);}
    | ctct_rep COMMA test COLON test {$$=make_tree("ctct_rep", 3,$1,$3,$5);}
    ;

dictorset_option_2: test comp_for_OR_ctr_co  {$$=make_tree("dictorset_option_2", 2,$1,$2);}
    ;

comp_for_OR_ctr_co: comp_for
    | comma_test_rep comma_opt {$$=make_tree("comp_for_OR_ctr_co", 2,$1,$2);}
    ;

