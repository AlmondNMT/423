```
// Data structure for symbol table entry
typedef struct SymbolTableEntry {
    char *name;
    void *data;
    struct SymbolTableEntry *next;
} SymbolTableEntry;

// Data structure for symbol table
typedef struct SymbolTable {
    int level;
    SymbolTableEntry *table[HASH_SIZE];
    struct SymbolTable *parent;
} SymbolTable;

// Hash function
int hash(char *s) {
    int hashval = 0;
    for (; *s != '\0'; s++) {
        hashval = *s + 31 * hashval;
    }
    return hashval % HASH_SIZE;
}

// Create a new symbol table
SymbolTable *mksymtab() {
    SymbolTable *st = malloc(sizeof(SymbolTable));
    st->level = 0;
    for (int i = 0; i < HASH_SIZE; i++) {
        st->table[i] = NULL;
    }
    st->parent = NULL;
    return st;
}

// Enter a new scope
void scope_enter(SymbolTable **pst) {
    SymbolTable *st = mksymtab();
    st->level = (*pst)->level + 1;
    st->parent = *pst;
    *pst = st;
}

// Exit the current scope
void scope_exit(SymbolTable **pst) {
    SymbolTable *st = *pst;
    for (int i = 0; i < HASH_SIZE; i++) {
        SymbolTableEntry *entry = st->table[i];
        while (entry != NULL) {
            SymbolTableEntry *next = entry->next;
            free(entry);
            entry = next;
        }
    }
    *pst = st->parent;
    free(st);
}

// Get the current scope level
int scope_level(SymbolTable *st) {
    return st->level;
}

// Look up a symbol in all scopes
void scope_lookup(SymbolTable *st, char *name) {
    SymbolTable *cur = st;
    while (cur != NULL) {
        int index = hash(name);
        SymbolTableEntry *entry = cur->table[index];
        while (entry != NULL) {
            if (strcmp(entry->name, name) == 0) {
                printf("Symbol found: %s\n", name);
                return;
            }
            entry = entry->next;
        }
        cur = cur->parent;
    }
    printf("Symbol not found: %s\n", name);
}

// Look up a symbol in the current scope only
void scope_lookup_current(SymbolTable *st, char *name) {
    int index = hash(name);
    SymbolTableEntry *entry = st->table[index];
    while (entry != NULL) {
        if (strcmp(entry->name, name) == 0) {
            printf("Symbol found in current scope: %s\n", name);
            return;
        }
        entry = entry->next;
    }
    printf("Symbol not found in current scope: %s\n", name);
}

// Insert a symbol into the symbol table
void insertsymbol(SymbolTable *st, char *name, void *data) {
    int index = hash(name);
    SymbolTableEntry *entry = malloc(sizeof(SymbolTableEntry));
    entry->name = name;
    entry->data = data;
    entry->next = st->table[index];
    st->table[index] = entry;
}
// Remove a symbol from the symbol table
SymbolTableEntry removesymbol(SymbolTable *st, char *name) {
    int index = hash(name);
    SymbolTableEntry *prev = NULL;
    SymbolTableEntry *entry = st->table[index];
    while (entry != NULL) {
        if (strcmp(entry->name, name) == 0) {
            if (prev == NULL) {
                st->table[index] = entry->next;
            } else {
                prev->next = entry->next;
            }
            return entry;
        }
        prev = entry;
        entry = entry->next;
    }
    return NULL;
}

// Find a symbol in the symbol table
SymbolTableEntry findsymbol(SymbolTable *st, char *name) {
    int index = hash(name);
    SymbolTableEntry *entry = st->table[index];
    while (entry != NULL) {
        if (strcmp(entry->name, name) == 0) {
            return entry;
        }
        entry = entry->next;
    }
    return NULL;
}

// Populate symbol tables from AST
void populate_symboltables(struct tree *t, SymbolTable *st) {
    if (t == NULL) {
        return;
    }
    switch (t->node_type) {
        case NODE_ASSIGN:
            insertsymbol(st, t->left->str_val, NULL);
            break;
        case NODE_FUNCTION:
            insertsymbol(st, t->left->str_val, NULL);
            scope_enter(&st);
            populate_symboltables(t->right->left, st);
            scope_exit(&st);
            break;
        case NODE_BLOCK:
            scope_enter(&st);
            populate_symboltables(t->left, st);
            scope_exit(&st);
            break;
        case NODE_IF:
            populate_symboltables(t->left, st);
            scope_enter(&st);
            populate_symboltables(t->right->left, st);
            scope_exit(&st);
            if (t->right->right != NULL) {
                scope_enter(&st);
                populate_symboltables(t->right->right, st);
                scope_exit(&st);
            }
            break;
        case NODE_WHILE:
            populate_symboltables(t->left, st);
            scope_enter(&st);
            populate_symboltables(t->right, st);
            scope_exit(&st);
            break;
        default:
            break;
    }
    populate_symboltables(t->left, st);
    populate_symboltables(t->right, st);
}
```